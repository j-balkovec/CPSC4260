{
    "Name": "halstead_metrics.py",
    "Size": "5330 bytes",
    "Type": "py",
    "Date Created": "Sat May  3 13:16:35 2025",
    "Date Modified": "Sat May  3 13:16:33 2025",
    "Date Accessed": "Sat May  3 13:18:00 2025",
    "Data": "# __name__: Jakob Balkovec\n# __class__: CPSC 4260 - Software Refactoring\n# __date__: Sun Apr 20th, 2025\n#\n# __file__: halstead_metrics.py\n#\n# __brief__: TODO\n\nimport re\nimport math\nfrom constants import (ALLOWED_OPERATORS)\nimport keyword\n\nfrom exceptions import (CodeProcessingError)\nfrom logger import setup_logger\nfrom utility import (_read_file_contents)\n\n\n# ==========\nhalstead_metrics_logger = setup_logger(name=\"halstead_metrics.py_logger\", log_file=\"halstead_metrics.log\")\n# ==========\n\n# halstead_metrics_logger.info(\"hey\")\n\ndef _extract_operators_and_operands(source_code: str) -> dict:\n    \"\"\"_summary_\n\n    Args:\n        source_code (str): A long string with all the lines of code.\n\n    Returns:\n        dict: A dictionary with the following keys:\n            * unique_operators -> set\n            * unique_operands  -> set\n            * total_operators  -> list\n            * total_operands   -> list\n    \"\"\"\n    grouped = {\n        \"unique_operators\": set(),\n        \"unique_operands\": set(),\n        \"total_operators\": [],\n        \"total_operands\": [],\n    }\n    \n    inside_multiline_comment = False\n    inside_singleline_comment = False\n\n    fstring_pattern = r'f\"[^\"]*\"|f\\'[^\\']*\\''\n    multi_operators_pattern = r'(==|!=|<=|>=|&&|\\|\\|)'    \n    \n    for line in source_code.splitlines():\n        stripped_line = line.strip()\n        \n        if stripped_line == \"\":\n            continue\n        \n        if stripped_line.startswith(\"#\"):\n            inside_singleline_comment = True\n            continue\n        \n        if stripped_line.startswith(('\"\"\"', \"'''\")):\n            inside_multiline_comment = not inside_multiline_comment\n            continue\n\n        if inside_multiline_comment:\n            continue\n        \n        line = re.sub(fstring_pattern, \"\", line)\n        line = re.sub(r'\"\"\"([^\"]|\"(?!\"\"))+\"\"\"|\\'\\'\\'([^\\']|\\'(?!\\'\\'))+\\'\\'\\'', \"\", line)\n\n        # Remove comment part at the end of the line\n        code_part = re.sub(r'\\s*#.*$', '', line).strip()\n        \n        if code_part.strip():\n          multi_ops = re.findall(multi_operators_pattern, code_part)\n          for op in multi_ops:\n              grouped[\"total_operators\"].append(op)\n              grouped[\"unique_operators\"].add(op)\n\n          for char in code_part:\n              if char in ALLOWED_OPERATORS:\n                grouped[\"total_operators\"].append(char)\n                grouped[\"unique_operators\"].add(char)\n                \n          tokens = re.findall(r'\\b\\w+\\b', code_part)\n\n          for token in tokens:\n              if token in keyword.kwlist or token.isdigit():\n                  continue\n              grouped[\"total_operands\"].append(token)\n              grouped[\"unique_operands\"].add(token)\n\n        else:\n          raise CodeProcessingError(\"Failed to parse the code\", function=\"_extract_operators_and_operands\", source_code=source_code)\n          \n    return grouped\n\n\ndef _calculate_halstead_metrics(info_dict: dict) -> dict:\n  \"\"\"_summary_\n\n  Args:\n      info_dict (dict): dictionary returned from group_lines() \n                        with all the necessary parameters\n\n  Returns:\n      dict: dictionary with halstead metrics\n      \n  Formulas:      \n      Length (N) = N1 + N2\n      Vocabulary (n) = n1 + n2\n      Volume (V) = N * log2(n)\n      Difficulty (D) = (n1/2) * (N2/n2)\n      Program Length (HN) = n1 * log2(n1) + n2 * log2(n2)\n      Effort (E) = D * V\n      Time (T) = E / 18\n      Bugs (B) = E / 3000\n      Maintainability (M) = 171 - 5.2 * log2(V) - 0.23 * D - 16.2 * log2(N)\n  \"\"\"\n\n  halstead_metrics = {\n    \"n1\": len(info_dict[\"unique_operators\"]),\n    \"n2\": len(info_dict[\"unique_operands\"]),\n    \"N1\": len(info_dict[\"total_operators\"]),\n    \"N2\": len(info_dict[\"total_operands\"]),\n    \n    \"N\": 0,\n    \"n\": 0,\n    \"V\": 0,\n    \"D\": 0,\n    \"HN\": 0,\n    \"E\": 0,\n    \"T\": 0,\n    \"B\": 0,\n    \"M\": 0,\n  }\n  \n  n1 = halstead_metrics[\"n1\"]\n  n2 = halstead_metrics[\"n2\"]\n  N1 = halstead_metrics[\"N1\"]\n  N2 = halstead_metrics[\"N2\"]\n  \n  length = N1 + N2\n  vocabulary = n1 + n2\n  volume = length * math.log2(vocabulary) if vocabulary > 0 else 0\n  difficulty = (n1 / 2) * (N2 / n2) if n2 > 0 else 0\n  program_length = n1 * math.log2(n1) + n2 * math.log2(n2) if n1 > 0 and n2 > 0 else 0\n  effort = difficulty * volume\n  time = effort / 18\n  bugs = effort / 3000\n  maintainability = 171 - 5.2 * math.log2(volume) - 0.23 * difficulty - 16.2 * math.log2(length) if length > 0 and volume > 0 else 0\n  \n  halstead_metrics[\"N\"] = length\n  halstead_metrics[\"n\"] = vocabulary\n  halstead_metrics[\"V\"] = round(volume, ndigits=3)\n  halstead_metrics[\"D\"] = round(difficulty, ndigits=3)\n  halstead_metrics[\"HN\"] = round(program_length, ndigits=3)\n  halstead_metrics[\"E\"] = round(effort, ndigits=3)\n  halstead_metrics[\"T\"] = round(time, ndigits=3)\n  halstead_metrics[\"B\"] = round(bugs, ndigits=3)\n  halstead_metrics[\"M\"] = round(maintainability, ndigits=3)\n  \n  return halstead_metrics\n\n\ndef fetch_halstead_metrics(file_name: str) -> dict:\n  \"\"\"_summary_\n\n  Note:\n      Abstract the details from the client\n  \n  Args:\n      file_name (str): _description_\n      \n  Returns:\n      _type_: @see _calculate_halstead_metrics()\n  \"\"\"\n  raw_code = _read_file_contents(file_name)\n  lines = _extract_operators_and_operands(raw_code)\n  halstead_metrics = _calculate_halstead_metrics(lines)\n  \n  return halstead_metrics"
}